import styles from "./css/page.module.css";
export const whole_word = '愛戴,愛國,愛滋病,安頓,安撫,安寧,安詳,安置,暗暗,案件,案情,按摩,昂貴,奧妙,懊惱,八卦,八字,把持,把手,白皮書,拜會,頒發,頒獎,辦案,半島,半導體,包袱,包圍,寶貝,寶石,飽和,飽滿,保安,保管,保齡球,保姆,保全,保險,保佑,保重,報案,報表,報酬,報復,報關,報價,報刊,報應,報章,暴雨,爆發,抱負,碑,悲哀,悲觀,貝殼,倍數,背誦,奔騰,本,本事,本位,本性,本質,崩潰,甭,敝,必,編輯,編寫,編織,編制,編製,邊界,邊緣,貶,貶值,匾額,辨認,辨識,辯,辯護,辯論,變革,變遷,變通,變形,標籤,標語,表白,表明,鼻孔,筆錄,筆友,比率,比擬,比喻,比重,必備,必定,必然,閉幕,閉塞,避難,避孕,畢生,幣值,憋,別,別墅,兵,賓館,柄,並列,並重,併發,病床,病菌,病患,波,波及,波浪,剝,剝削,搏鬥,播出,補給,補救,哺乳動物,不便,不得,不等,不動產,不法,不凡,不妨,不公,不及,不禁,不堪,不力,不料,不免,不容,不時,不惜,不下,不肖,不懈,不再,不致,不知不覺,不至於,部落,部署,步調,步驟,猜測,猜忌,猜想,裁縫,裁減,財團,財政,才智,採訪,採光,採納,採取,彩繪,餐具,參謀,殘暴,殘酷,殘殺,慘重,燦爛,蒼白,蒼蠅,操縱,草案,草叢,草率,草藥,測,策劃,差額,插曲,插嘴,茶具,察覺,查明,蟬,饞,潺潺,猖獗,長遠,場次,場面,倡導,唱腔,暢銷,產物,產值,超速,超脫,抄襲,吵嘴,車輛,車廂,撤回,撤銷,沉默,沉思,沉重,塵土,承包,承擔,承諾,成敗,成見,成就,成品,成全,成效,成衣,成員,成長,稱號,稱呼,撐腰,程式,呈獻,誠心,誠心誠意,誠摯,吃驚,吃苦,吃力,持久,持平,池子,遲鈍,充斥,充裕,沖淡,沖天,衝動,衝擊,憧憬,重疊,崇尚,寵愛,寵物,抽查,抽空,抽象,抽樣,仇恨,稠密,出超,出錯,出發點,出局,出力,出路,出馬,出賣,出面,出名,出品,出示,出手,出頭,出土,出息,出血,初期,儲備,除此之外,鋤頭,處方,處分,處境,處事,處於,處女,穿梭,傳遞,傳奇,手機,明年,快樂,公園,國家,家人,工作,醫生,英文,問題,下課,說話,考試,功課,教室,休息,房間,天氣,空氣,下雨,起床,方便,睡覺,運動,走路,唱歌,跳舞,介紹,地方,附近,計程車,火車,飛機,外國,身體,眼睛,感冒,生病,衣服,蛋糕,麵包,水果,香蕉,食物,飲料,果汁,家庭,老人,年輕,號碼,城市,結婚,高興,緊張,可愛,生氣,難過,聰明,相信,經驗,辛苦,願意,習慣,當然,醫院,公司,辦公室,工人,護士,司機,老闆,上班,下班,能力,努力,準備' .split(',');
export const words = 'ㄞˋㄉㄞˋ,ㄞˋㄍㄨㄛˊ,ㄞˋㄗ_ㄅㄧㄥˋ,ㄢ_ㄉㄨㄣˋ,ㄢ_ㄈㄨˇ,ㄢ_ㄋㄧㄥˊ,ㄢ_ㄒㄧㄤˊ,ㄢ_ㄓˋ,ㄢˋㄢˋ,ㄢˋㄐㄧㄢˋ,ㄢˋㄑㄧㄥˊ,ㄢˋㄇㄛˊ,ㄤˊㄍㄨㄟˋ,ㄠˋㄇㄧㄠˋ,ㄠˋㄋㄠˇ,ㄅㄚ_ㄍㄨㄚˋ,ㄅㄚ_ㄗˋ,ㄅㄚˇㄔˊ,ㄅㄚˇㄕㄡˇ,ㄅㄞˊㄆㄧˊㄕㄨ_,ㄅㄞˋㄏㄨㄟˋ,ㄅㄢ_ㄈㄚ_,ㄅㄢ_ㄐㄧㄤˇ,ㄅㄢˋㄢˋ,ㄅㄢˋㄉㄠˇ,ㄅㄢˋㄉㄠˇㄊㄧˇ,ㄅㄠ_ㄈㄨˊ,ㄅㄠ_ㄨㄟˊ,ㄅㄠˇㄅㄟˋ,ㄅㄠˇㄕˊ,ㄅㄠˇㄏㄜˊ,ㄅㄠˇㄇㄢˇ,ㄅㄠˇㄢ_,ㄅㄠˇㄍㄨㄢˇ,ㄅㄠˇㄌㄧㄥˊㄑㄧㄡˊ,ㄅㄠˇㄇㄨˇ,ㄅㄠˇㄑㄩㄢˊ,ㄅㄠˇㄒㄧㄢˇ,ㄅㄠˇㄧㄡˋ,ㄅㄠˇㄓㄨㄥˋ,ㄅㄠˋㄢˋ,ㄅㄠˋㄅㄧㄠˇ,ㄅㄠˋㄔㄡˊ,ㄅㄠˋㄈㄨˋ,ㄅㄠˋㄍㄨㄢ_,ㄅㄠˋㄐㄧㄚˋ,ㄅㄠˋㄎㄢ_,ㄅㄠˋㄧㄥˋ,ㄅㄠˋㄓㄤ_,ㄅㄠˋㄩˇ,ㄅㄠˋㄈㄚ_,ㄅㄠˋㄈㄨˋ,ㄅㄟ_,ㄅㄟ_ㄞ_,ㄅㄟ_ㄍㄨㄢ_,ㄅㄟˋㄎㄜˊ,ㄅㄟˋㄕㄨˋ,ㄅㄟˋㄙㄨㄥˋ,ㄅㄣ_ㄊㄥˊ,ㄅㄣˇ,ㄅㄣˇㄕˋ,ㄅㄣˇㄨㄟˋ,ㄅㄣˇㄒㄧㄥˋ,ㄅㄣˇㄓˊ,ㄅㄥ_ㄎㄨㄟˋ,ㄅㄥˊ,ㄅㄧˋ,ㄅㄧˋ,ㄅㄧㄢ_ㄐㄧˊ,ㄅㄧㄢ_ㄒㄧㄝˇ,ㄅㄧㄢ_ㄓ_,ㄅㄧㄢ_ㄓˋ,ㄅㄧㄢ_ㄓˋ,ㄅㄧㄢ_ㄐㄧㄝˋ,ㄅㄧㄢ_ㄩㄢˊ,ㄅㄧㄢˇ,ㄅㄧㄢˇㄓˊ,ㄅㄧㄢˇㄜˊ,ㄅㄧㄢˋㄖㄣˋ,ㄅㄧㄢˋㄕˋ,ㄅㄧㄢˋ,ㄅㄧㄢˋㄏㄨˋ,ㄅㄧㄢˋㄌㄨㄣˋ,ㄅㄧㄢˋㄍㄜˊ,ㄅㄧㄢˋㄑㄧㄢ_,ㄅㄧㄢˋㄊㄨㄥ_,ㄅㄧㄢˋㄒㄧㄥˊ,ㄅㄧㄠ_ㄑㄧㄢ_,ㄅㄧㄠ_ㄩˇ,ㄅㄧㄠˇㄅㄞˊ,ㄅㄧㄠˇㄇㄧㄥˊ,ㄅㄧˊㄎㄨㄥˇ,ㄅㄧˇㄌㄨˋ,ㄅㄧˇㄧㄡˇ,ㄅㄧˇㄌㄩˋ,ㄅㄧˇㄋㄧˇ,ㄅㄧˇㄩˋ,ㄅㄧˇㄓㄨㄥˋ,ㄅㄧˋㄅㄟˋ,ㄅㄧˋㄉㄧㄥˋ,ㄅㄧˋㄖㄢˊ,ㄅㄧˋㄇㄨˋ,ㄅㄧˋㄙㄞ_,ㄅㄧˋㄋㄢˋ,ㄅㄧˋㄩㄣˋ,ㄅㄧˋㄕㄥ_,ㄅㄧˋㄓˊ,ㄅㄧㄝ_,ㄅㄧㄝˊ,ㄅㄧㄝˊㄕㄨˋ,ㄅㄧㄥ_,ㄅㄧㄣ_ㄍㄨㄢˇ,ㄅㄧㄥˇ,ㄅㄧㄥˋㄌㄧㄝˋ,ㄅㄧㄥˋㄓㄨㄥˋ,ㄅㄧㄥˋㄈㄚ_,ㄅㄧㄥˋㄔㄨㄤˊ,ㄅㄧㄥˋㄐㄩㄣˋ,ㄅㄧㄥˋㄏㄨㄢˋ,ㄅㄛ_,ㄅㄛ_ㄐㄧˊ,ㄅㄛ_ㄌㄤˋ,ㄅㄛ_,ㄅㄛ_ㄒㄧㄠ_,ㄅㄛˊㄉㄡˋ,ㄅㄛ_ㄔㄨ_,ㄅㄨˇㄐㄧˇ,ㄅㄨˇㄐㄧㄡˋ,ㄅㄨˇㄖㄨˇㄉㄨㄥˋㄨˋ,ㄅㄨˊㄅㄧㄢˋ,ㄅㄨˋㄉㄜˊ,ㄅㄨˋㄉㄥˇ,ㄅㄨˊㄉㄨㄥˋㄔㄢˇ,ㄅㄨˋㄈㄚˇ,ㄅㄨˋㄈㄢˊ,ㄅㄨˋㄈㄤˊ,ㄅㄨˋㄍㄨㄥ_,ㄅㄨˋㄐㄧˊ,ㄅㄨˋㄐㄧㄣ_,ㄅㄨˋㄎㄢ_,ㄅㄨˊㄌㄧˋ,ㄅㄨˊㄌㄧㄠˋ,ㄅㄨˋㄇㄧㄢˇ,ㄅㄨˋㄖㄨㄥˊ,ㄅㄨˋㄕˊ,ㄅㄨˋㄒㄧˊ,ㄅㄨˊㄒㄧㄚˋ,ㄅㄨˊㄒㄧㄠˋ,ㄅㄨˊㄒㄧㄝˋ,ㄅㄨˊㄗㄞˋ,ㄅㄨˊㄓˋ,ㄅㄨˋㄓ_ㄅㄨˋㄐㄩㄝˊ,ㄅㄨˊㄓˋㄩˊ,ㄅㄨˋㄌㄨㄛˋ,ㄅㄨˋㄕㄨˇ,ㄅㄨˋㄉㄧㄠˋ,ㄅㄨˋㄗㄡˋ,ㄘㄞ_ㄘㄜˋ,ㄘㄞ_ㄐㄧˋ,ㄘㄞ_ㄒㄧㄤˇ,ㄘㄞˊㄈㄥˊ,ㄘㄞˊㄐㄧㄢˇ,ㄘㄞˊㄊㄨㄢˊ,ㄘㄞˊㄓㄥˋ,ㄘㄞˊㄓˋ,ㄘㄞˇㄈㄤˇ,ㄘㄞˇㄍㄨㄤ_,ㄘㄞˇㄋㄚˋ,ㄘㄞˇㄑㄩˇ,ㄘㄞˇㄏㄨㄟˋ,ㄘㄢ_ㄐㄩˋ,ㄘㄢ_ㄇㄡˊ,ㄘㄢˊㄅㄠˋ,ㄘㄢˊㄎㄨˋ,ㄘㄢˊㄕㄚ_,ㄘㄢˇㄓㄨㄥˋ,ㄘㄢˋㄌㄢˋ,ㄘㄤ_ㄅㄞˊ,ㄘㄤ_ㄧㄥˊ,ㄘㄠ_ㄗㄨㄥˋ,ㄘㄠˇㄢˋ,ㄘㄠˇㄘㄨㄥˊ,ㄘㄠˇㄕㄨㄞˋ,ㄘㄠˇㄧㄠˋ,ㄘㄜˋ,ㄘㄜˋㄏㄨㄚˋ,ㄔㄚ_ㄜˊ,ㄔㄚ_ㄑㄩˇ,ㄔㄚ_ㄗㄨㄟˇ,ㄔㄚˊㄐㄩˋ,ㄔㄚˊㄐㄩㄝˊ,ㄔㄚˊㄇㄧㄥˊ,ㄔㄢˊ,ㄔㄢˊ,ㄔㄢˊㄔㄢˊ,ㄔㄤ_ㄐㄩㄝˊ,ㄔㄤˊㄩㄢˇ,ㄔㄤˇㄘˋ,ㄔㄤˇㄇㄧㄢˋ,ㄔㄤˋㄉㄠˇ,ㄔㄤˋㄑㄧㄤ_,ㄔㄤˋㄒㄧㄠ_,ㄔㄢˇㄨˋ,ㄔㄢˇㄓˊ,ㄔㄠ_ㄙㄨˋ,ㄔㄠ_ㄊㄨㄛ_,ㄔㄠ_ㄒㄧˊ,ㄔㄠˇㄗㄨㄟˇ,ㄔㄜ_ㄌㄧㄤˋ,ㄔㄜ_ㄒㄧㄤ_,ㄔㄜˋㄏㄨㄟˊ,ㄔㄜˋㄒㄧㄠ_,ㄔㄣˊㄇㄛˋ,ㄔㄣˊㄙ_,ㄔㄣˊㄓㄨㄥˋ,ㄔㄣˊㄊㄨˇ,ㄔㄥˊㄅㄠ_,ㄔㄥˊㄉㄢ_,ㄔㄥˊㄋㄨㄛˋ,ㄔㄥˊㄅㄞˋ,ㄔㄥˊㄐㄧㄢˋ,ㄔㄥˊㄐㄧㄡˋ,ㄔㄥˊㄆㄧㄣˇ,ㄔㄥˊㄑㄩㄢˊ,ㄔㄥˊㄒㄧㄠˋ,ㄔㄥˊㄧ_,ㄔㄥˊㄩㄢˊ,ㄔㄥˊㄓㄤˇ,ㄔㄥ_ㄏㄠˋ,ㄔㄥ_ㄏㄨ_,ㄔㄥ_ㄧㄠ_,ㄔㄥˊㄕˋ,ㄔㄥˊㄒㄧㄢˋ,ㄔㄥˊㄒㄧㄣ_,ㄔㄥˊㄒㄧㄣ_ㄔㄥˊㄧˋ,ㄔㄥˊㄓˋ,ㄔ_ㄐㄧㄥ_,ㄔ_ㄎㄨˇ,ㄔ_ㄌㄧˋ,ㄔˊㄐㄧㄡˇ,ㄔˊㄆㄧㄥˊ,ㄔˊㄗ˙,ㄔˊㄉㄨㄣˋ,ㄔㄨㄥ_ㄔˋ,ㄔㄨㄥ_ㄩˋ,ㄔㄨㄥ_ㄉㄢˋ,ㄔㄨㄥ_ㄊㄧㄢ_,ㄔㄨㄥ_ㄉㄨㄥˋ,ㄔㄨㄥ_ㄐㄧˊ,ㄔㄨㄥ_ㄐㄧㄥˇ,ㄔㄨㄥˊㄉㄧㄝˊ,ㄔㄨㄥˊㄕㄤˋ,ㄔㄨㄥˇㄞˋ,ㄔㄨㄥˇㄨˋ,ㄔㄡ_ㄔㄚˊ,ㄔㄡ_ㄎㄨㄥˋ,ㄔㄡ_ㄒㄧㄤˋ,ㄔㄡ_ㄧㄤˋ,ㄔㄡˊㄏㄣˋ,ㄔㄡˊㄇㄧˋ,ㄔㄨ_ㄔㄠ_,ㄔㄨ_ㄘㄨㄛˋ,ㄔㄨ_ㄈㄚ_ㄉㄧㄢˇ,ㄔㄨ_ㄐㄩˊ,ㄔㄨ_ㄌㄧˋ,ㄔㄨ_ㄌㄨˋ,ㄔㄨ_ㄇㄚˇ,ㄔㄨ_ㄇㄞˋ,ㄔㄨ_ㄇㄧㄢˋ,ㄔㄨ_ㄇㄧㄥˊ,ㄔㄨ_ㄆㄧㄣˇ,ㄔㄨ_ㄕˋ,ㄔㄨ_ㄕㄡˇ,ㄔㄨ_ㄊㄡˊ,ㄔㄨ_ㄊㄨˇ,ㄔㄨ_ㄒㄧˊ,ㄔㄨ_ㄒㄧㄝˇ,ㄔㄨ_ㄑㄧˊ,ㄔㄨˊㄅㄟˋ,ㄔㄨˊㄘˇㄓ_ㄨㄞˋ,ㄔㄨˊㄊㄡˊ,ㄔㄨˇㄈㄤ_,ㄔㄨˇㄈㄣˋ,ㄔㄨˇㄐㄧㄥˋ,ㄔㄨˇㄕˋ,ㄔㄨˇㄩˊ,ㄔㄨˋㄋㄩˇ,ㄔㄨㄢ_ㄙㄨㄛ_,ㄔㄨㄢˊㄉㄧˋ,ㄔㄨㄢˊㄑㄧˊ,ㄕㄡˇㄐㄧ_,ㄇㄧㄥˊㄋㄧㄢˊ,ㄎㄨㄞˋㄌㄜˋ,ㄍㄨㄥ_ㄩㄢˊ,ㄍㄨㄛˊㄐㄧㄚ_,ㄐㄧㄚ_ㄖㄣˊ,ㄍㄨㄥ_ㄗㄨㄛˋ,ㄧ_ㄕㄥ_,ㄧㄥ_ㄨㄣˊ,ㄨㄣˋㄊㄧˊ,ㄒㄧㄚˋㄎㄜˋ,ㄕㄨㄛ_ㄏㄨㄚˋ,ㄎㄠˇㄕˋ,ㄍㄨㄥ_ㄎㄜˋ,ㄐㄧㄠˋㄕˋ,ㄒㄧㄡ_ㄒㄧˊ,ㄈㄤˊㄐㄧㄢ_,ㄊㄧㄢ_ㄑㄧˋ,ㄎㄨㄥ_ㄑㄧˋ,ㄒㄧㄚˋㄩˇ,ㄑㄧˇㄔㄨㄤˊ,ㄈㄤ_ㄅㄧㄢˋ,ㄕㄨㄟˋㄐㄧㄠˋ,ㄩㄣˋㄉㄨㄥˋ,ㄗㄡˇㄌㄨˋ,ㄔㄤˋㄍㄜ_,ㄊㄧㄠˋㄨˇ,ㄐㄧㄝˋㄕㄠˋ,ㄉㄧˋㄈㄤ_,ㄈㄨˋㄐㄧㄣˋ,ㄐㄧˋㄔㄥˊㄔㄜ_,ㄏㄨㄛˇㄔㄜ_,ㄈㄟ_ㄐㄧ_,ㄨㄞˋㄍㄨㄛˊ,ㄕㄣ_ㄊㄧˇ,ㄧㄢˇㄐㄧㄥ_,ㄍㄢˇㄇㄠˋ,ㄕㄥ_ㄅㄧㄥˋ,ㄧ_ㄈㄨˊ,ㄉㄢˋㄍㄠ_,ㄇㄧㄢˋㄅㄠ_,ㄕㄨㄟˇㄍㄨㄛˇ,ㄒㄧㄤ_ㄐㄧㄠ_,ㄕˊㄨˋ,ㄧㄣˇㄌㄧㄠˋ,ㄍㄨㄛˇㄓ_,ㄐㄧㄚ_ㄊㄧㄥˊ,ㄌㄠˇㄖㄣˊ,ㄋㄧㄢˊㄑㄧㄥ_,ㄏㄠˋㄇㄚˇ,ㄔㄥˊㄕˋ,ㄐㄧㄝˊㄏㄨㄣ_,ㄍㄠ_ㄒㄧㄥˋ,ㄐㄧㄣˇㄓㄤ_,ㄎㄜˇㄞˋ,ㄕㄥ_ㄑㄧˋ,ㄋㄢˊㄍㄨㄛˋ,ㄘㄨㄥ_ㄇㄧㄥˊ,ㄒㄧㄤ_ㄒㄧㄣˋ,ㄐㄧㄥ_ㄧㄢˋ,ㄒㄧㄣ_ㄎㄨˇ,ㄩㄢˋㄧˋ,ㄒㄧˊㄍㄨㄢˋ,ㄉㄤ_ㄖㄢˊ,ㄧ_ㄩㄢˋ,ㄍㄨㄥ_ㄙ_,ㄅㄢˋㄍㄨㄥ_ㄕˋ,ㄍㄨㄥ_ㄖㄣˊ,ㄏㄨˋㄕˋ,ㄙ_ㄐㄧ_,ㄌㄠˇㄅㄢˇ,ㄕㄤˋㄅㄢ_,ㄒㄧㄚˋㄅㄢ_,ㄋㄥˊㄌㄧˋ,ㄋㄨˇㄌㄧˋ,ㄓㄨㄣˇㄅㄟˋ'.split(',');
export const wordsCount = words.length;
export const alter_key: Record<string, string> = {'ㄅ':'1','ㄆ':'q','ㄇ':'a','ㄈ':'z','ㄉ':'2','ㄊ':'w','ㄋ':'s','ㄌ':'x','ˇ':'3','ㄍ':'e','ㄎ':'d','ㄏ':'c','ˋ':'4','ㄐ':'r','ㄑ':'f','ㄒ':'v','ㄓ':'5','ㄔ':'t','ㄕ':'g','ㄖ':'b','ˊ':'6','ㄗ':'y','ㄘ':'h','ㄙ':'n','˙':'7','ㄧ':'u','ㄨ':'j','ㄩ':'m','ㄚ':'8','ㄛ':'i','ㄜ':'k','ㄝ':',','ㄞ':'9','ㄟ':'o','ㄠ':'l','ㄡ':'.','ㄢ':'0','ㄣ':'p','ㄤ':';','ㄥ':'/','ㄦ':'-'};
export let gameTime = 30 * 1000;

export function addClass(el: HTMLElement, name: string) {
	const className = styles[name];
	if (!el.classList.contains(className)) {
	  el.className += ' ' + className;
	}
}

export function removeClass(el: HTMLElement, name: string) {
	const className = styles[name];
	if (el.classList.contains(className)) {
		el.classList.remove(className);
	}
}

export function formatWord() {
	// console.log("check format word");
	const randomIndex = Math.ceil(Math.random() * wordsCount) - 1;
	return `<div class="${styles.word_box}"> <div class="${styles.chinese}">${whole_word[randomIndex]}</div> <div class="${styles.zh}"><span class="${styles.letter}">${words[randomIndex].split('').join(`</span><span class="${styles.letter}">`)}</span></div> </div>`;
  }

export function newGame() {
	console.log("check new game");
	const ingameElements = document.getElementsByClassName(styles.ingame);
    for (let i = 0; i < ingameElements.length; i++) {
        (ingameElements[i] as HTMLElement).style.display = 'flex';
    } 
	const outgameElements = document.getElementsByClassName(styles.outgame);
    for (let i = 0; i < outgameElements.length; i++) {
        (outgameElements[i] as HTMLElement).style.display = 'none';
    }
	// console.log("ingameElements: ",ingameElements);
	// console.log("check new game 2");
	
    // Refresh words
    const check_title: HTMLCollection | null = document.getElementsByClassName(styles.page_title);
	// console.log("check title", check_title);
    const wordsContainer: HTMLElement | null = document.querySelector(`.${styles.words}`);
    // console.log("wordsContainer", wordsContainer);
	if (wordsContainer) {
        wordsContainer.innerHTML = '';
        for (let i = 0; i < 30; i++) {
            wordsContainer.innerHTML += formatWord();
        }
    }
	// console.log("check new game 3");

    const firstWordBox: HTMLElement | null = document.querySelector(`.${styles.word_box}`);
    // console.log("firstWordBox", firstWordBox);
	if (firstWordBox) {
        addClass(firstWordBox, 'current');
		// console.log("check new game 4");
    }

    const firstLetter: HTMLElement | null = document.querySelector(`.${styles.letter}`);
    if (firstLetter) {
		// console.log("firstLetter: ", firstLetter.innerHTML);
        addClass(firstLetter, 'current');
    }

    const gameElement: HTMLElement | null = document.querySelector(`.${styles.game}`);
    if (gameElement) {
        while (gameElement.classList.contains('over')) {
            removeClass(gameElement, 'over');
        }
    }

    // Initialize cursor
    const nextLetter: HTMLElement | null = document.querySelector(`.${styles.letter}`);
	const nextWord: HTMLElement | null = document.querySelector(`.${styles.word_box}.${styles.current}`)?.nextSibling as HTMLElement | null;
    const cursor: HTMLElement | null = document.querySelector(`.${styles.cursor}`);
    // console.log("nextLetter", nextLetter);
	// console.log("nextWord", nextWord);
	// console.log("cursor", cursor);
	if (cursor && nextLetter) {
        cursor.style.top = (nextLetter.getBoundingClientRect().top + 5) + 'px';
        cursor.style.left = nextLetter.getBoundingClientRect().left + 'px';
    } else if (cursor && nextWord) {
        cursor.style.left = nextWord.getBoundingClientRect().right + 'px';
    }

    if (gameElement) {
        gameElement.focus();
    }
}
export function getResult(): [number, number] {
    const correctClassName = `${styles.chinese} ${styles.correct}`;
    const incorrectClassName = `${styles.chinese} ${styles.incorrect}`;

	const correctWords = document.getElementsByClassName(correctClassName) as HTMLCollectionOf<HTMLElement>;
    const incorrectWords = document.getElementsByClassName(incorrectClassName) as HTMLCollectionOf<HTMLElement>;

    let correctWordNum = 0;
    let incorrectWordNum = 0;

    for (let i = 0; i < incorrectWords.length; i++) {
        incorrectWordNum += incorrectWords[i].innerText.length;
    }
    console.log('incorrect: ' + incorrectWordNum);

    for (let i = 0; i < correctWords.length; i++) {
        correctWordNum += correctWords[i].innerText.length;
    }

    const wordsPerMinute = Math.round(correctWordNum / gameTime * 60000);
    const accuracy = Math.round(100 * (correctWordNum / (correctWordNum + incorrectWordNum)));

    return [wordsPerMinute, accuracy];
}

export function gameOver(): void {

    // const ingameElements = document.getElementsByClassName(styles.ingame) as HTMLCollectionOf<HTMLElement>;
    // for (let i = 0; i < ingameElements.length; i++) {
    //     ingameElements[i].style.display = 'none';
    // }

    // const outgameElements = document.getElementsByClassName(styles.outgame) as HTMLCollectionOf<HTMLElement>;
    // for (let i = 0; i < outgameElements.length; i++) {
    //     outgameElements[i].style.display = 'flex';
    // }

    const infoElement = document.querySelector(`.${styles.info}`);
    if (infoElement) {
        infoElement.innerHTML = '';
    }

    const gameElement: HTMLElement | null = document.querySelector(`.${styles.game}`);
    if (gameElement) {
        addClass(gameElement, styles.over);
    }

    const [wpm, acc] = getResult();

    const wpmElement = document.querySelector(`.${styles.wpm}`);
    if (wpmElement) {
        wpmElement.innerHTML = `${wpm}<br>`;
    }

    const accElement = document.querySelector(`.${styles.acc}`);
    if (accElement) {
        accElement.innerHTML = `${acc}%`;
    }
}

export function checkCorrect(thisLetter: HTMLElement): boolean {
    let flag: Node | null = thisLetter;
    while (flag?.previousSibling) {
        if ((flag as HTMLElement).classList.contains(styles.incorrect)) {
            return false;
        }
        flag = flag.previousSibling;
    }

    if ((flag as HTMLElement)?.classList.contains(styles.incorrect)) {
        return false;
    }
    return true;
}

export function moveCursor(cursor: HTMLElement) {
    const nextLetter = document.querySelector(`.${styles.letter}.${styles.current}`) as HTMLElement;
    const nextWord = document.querySelector(`.${styles.word_box}.${styles.current}`) as HTMLElement;
    
    if (nextLetter && nextLetter.getBoundingClientRect().top < 430) {
        cursor.style.top = (nextLetter || nextWord?.children[1])?.getBoundingClientRect().top + 5 + 'px';
    }
    cursor.style.left = (nextLetter || nextWord?.children[1])?.getBoundingClientRect()[nextLetter ? 'left' : 'right'] + 'px';
}

export const handleWordLogic = (key: string, currentWord: HTMLElement, currentLetter: HTMLElement, cursor: HTMLElement) => {
    const expected = currentLetter?.innerHTML || 'Enter';
    const isLetter = key.length === 1 && key !== 'Meta' && key !== 'CapsLock';
    const isEnter = key === 'Enter';
    const isBackspace = key === 'Backspace';
    const isFirstLetter = currentLetter === currentWord?.children[1]?.children[0];
    const isLastLetter = currentLetter === currentWord?.children[1]?.lastChild;

    return {
        isLetter,
        isEnter,
        isBackspace,
        isFirstLetter,
        isLastLetter,
        isCorrect: key === expected || key === alter_key[expected],
        expected
    };
};